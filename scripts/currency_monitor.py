# currency_monitor_enhanced.py
import MetaTrader5 as mt5
import pandas as pd
from datetime import datetime, timedelta
import time
import os
import sys
from pathlib import Path

# Cargar .env manualmente
def load_env_file():
    env_path = Path('.env')
    if not env_path.exists():
        print("‚ùå Archivo .env no encontrado")
        print("Creando archivo .env con configuraci√≥n...")
        
        # Crear .env con credenciales de ejemplo
        with open('.env', 'w') as f:
            f.write("""# MetaTrader 5 - CAMBIA ESTAS CREDENCIALES
MT5_LOGIN=tu_numero_de_cuenta
MT5_PASSWORD=tu_contrase√±a
MT5_SERVER=tu_servidor
""")
        print("‚úÖ Archivo .env creado. DEBES CAMBIAR las credenciales por las tuyas.")
        return False
    
    # Cargar variables manualmente
    env_vars = {}
    with open('.env', 'r') as f:
        for line in f:
            if line.strip() and not line.startswith('#'):
                if '=' in line:
                    key, value = line.strip().split('=', 1)
                    env_vars[key] = value
                    os.environ[key] = value
    
    print(f"‚úÖ Variables cargadas: {list(env_vars.keys())}")
    return True

class CurrencyMonitor:
    def __init__(self):  # ‚úÖ Corregido constructor
        self.running = False
        self.current_symbol = None
        self.max_price = 0
        self.min_price = float('inf')
        self.current_price = 0
        self.prev_price = 0
        
    def connect_mt5(self):
        """Conectar a MT5"""
        print("üîå Conectando a MT5...")
        
        # Verificar variables
        login = os.getenv('MT5_LOGIN')
        password = os.getenv('MT5_PASSWORD')
        server = os.getenv('MT5_SERVER')
        
        if not all([login, password, server]):
            print("‚ùå Faltan credenciales de MT5")
            print("Por favor configura el archivo .env con tus credenciales")
            return False
        
        if login in ['tu_numero_de_cuenta', 'ejemplo']:
            print("‚ùå Debes cambiar las credenciales en el archivo .env")
            return False
        
        print(f"Login: {login}")
        print(f"Server: {server}")
        print(f"Password: {'*' * len(password)}")
        
        if not mt5.initialize():
            print(f"‚ùå Error al inicializar MT5: {mt5.last_error()}")
            return False
        
        try:
            login_int = int(login)
        except ValueError:
            print(f"‚ùå Login debe ser num√©rico: {login}")
            return False
            
        if not mt5.login(login_int, password=password, server=server):
            print(f"‚ùå Error de login: {mt5.last_error()}")
            return False
            
        print("‚úÖ Conectado a MT5")
        return True
    
    def validate_symbol(self, symbol):
        """Validar y activar s√≠mbolo si est√° disponible"""
        symbol_info = mt5.symbol_info(symbol)
        if symbol_info is None:
            return False
        
        if not symbol_info.visible:
            if not mt5.symbol_select(symbol, True):
                return False
        
        return True
    
    def get_available_symbols(self, show_all=False):
        """Obtener s√≠mbolos disponibles con opci√≥n de mostrar todos"""
        symbols = mt5.symbols_get()
        if not symbols:
            return []
        
        available_symbols = []
        
        # Si queremos ver TODOS los s√≠mbolos
        if show_all:
            for symbol in symbols:
                if symbol.visible:
                    available_symbols.append({
                        'name': symbol.name,
                        'description': symbol.description if hasattr(symbol, 'description') else '',
                        'type': self.get_symbol_type(symbol.name)
                    })
        else:
            # Filtrado normal
            major_currencies = ['USD', 'EUR', 'GBP', 'JPY', 'CAD', 'AUD', 'CHF', 'NZD']
            
            # S√≠mbolos espec√≠ficos que queremos incluir
            target_symbols = {
                # Divisas principales
                'EURUSD', 'GBPUSD', 'USDJPY', 'AUDUSD', 'USDCAD', 'USDCHF', 'NZDUSD',
                # Peso colombiano (m√∫ltiples variantes)
                'USDCOP', 'COPDOLLAR', 'COPUSD', 'COP', 'PESOS',
                # √çndices (m√∫ltiples variantes)
                'US500', 'SPX500', 'SP500', 'S&P500', 'US500Cash', 'USTEC', 'US30', 
                'SPX', 'SPXUSD', 'USA500', 'NDX', 'NASDAQ', 'DOW30'
            }
            
            for symbol in symbols:
                if symbol.visible:
                    symbol_name = symbol.name.upper()
                    
                    # Verificar s√≠mbolos espec√≠ficos
                    if symbol_name in target_symbols:
                        available_symbols.append({
                            'name': symbol.name,
                            'description': symbol.description if hasattr(symbol, 'description') else '',
                            'type': self.get_symbol_type(symbol.name)
                        })
                    
                    # Buscar COP en cualquier parte del nombre
                    elif 'COP' in symbol_name:
                        available_symbols.append({
                            'name': symbol.name,
                            'description': symbol.description if hasattr(symbol, 'description') else '',
                            'type': 'cop'
                        })
                    
                    # Buscar √≠ndices por palabras clave
                    elif any(idx in symbol_name for idx in ['500', 'SPX', 'DOW', 'NASDAQ', 'NDX']):
                        available_symbols.append({
                            'name': symbol.name,
                            'description': symbol.description if hasattr(symbol, 'description') else '',
                            'type': 'index'
                        })
                    
                    # Buscar otras divisas
                    elif any(curr in symbol_name for curr in major_currencies):
                        if len(symbol_name) <= 8:  # Filtrar s√≠mbolos muy largos
                            available_symbols.append({
                                'name': symbol.name,
                                'description': symbol.description if hasattr(symbol, 'description') else '',
                                'type': 'forex'
                            })
        
        # Eliminar duplicados y ordenar
        seen = set()
        unique_symbols = []
        for symbol in available_symbols:
            if symbol['name'] not in seen:
                seen.add(symbol['name'])
                unique_symbols.append(symbol)
        
        return sorted(unique_symbols, key=lambda x: (x['type'], x['name']))[:100 if show_all else 50]
    
    def get_symbol_type(self, symbol):
        """Determinar el tipo de s√≠mbolo"""
        symbol_upper = symbol.upper()
        
        if 'COP' in symbol_upper:
            return 'cop'
        elif any(idx in symbol_upper for idx in ['US500', 'SPX500', 'SP500', 'S&P', 'US30', 'USTEC']):
            return 'index'
        else:
            return 'forex'
    
    def select_currency(self):
        """Seleccionar instrumento mejorado"""
        symbols = self.get_available_symbols()
        
        if not symbols:
            print("‚ùå No se encontraron s√≠mbolos disponibles")
            return None
        
        print("\nüí± INSTRUMENTOS DISPONIBLES:")
        print("=" * 70)
        
        # Agrupar por categor√≠as
        categories = {
            'cop': 'üá®üá¥ PESO COLOMBIANO',
            'index': 'üìà √çNDICES (S&P 500, etc.)',
            'forex': 'üí± DIVISAS PRINCIPALES'
        }
        
        current_index = 1
        symbol_map = {}
        found_target_symbols = False
        
        for category, title in categories.items():
            category_symbols = [s for s in symbols if s['type'] == category]
            if category_symbols:
                found_target_symbols = True
                print(f"\n{title}:")
                print("-" * 50)
                
                for symbol in category_symbols[:10]:  # Limitar por categor√≠a
                    print(f"  {current_index:2d}. {symbol['name']:<12} - {symbol['description']}")
                    symbol_map[current_index] = symbol['name']
                    current_index += 1
        
        # Si no encontramos USDCOP o √≠ndices, mostrar mensaje
        if not any(s['type'] in ['cop', 'index'] for s in symbols):
            print(f"\n‚ö†Ô∏è  USDCOP y S&P 500 NO disponibles en {os.getenv('MT5_SERVER')}")
            print("üí° Opciones:")
            print("   ‚Ä¢ Escribe 'TODOS' para ver TODOS los s√≠mbolos disponibles")
            print("   ‚Ä¢ O selecciona una divisa principal disponible")
        
        print(f"\n{current_index}. üîç Ver TODOS los s√≠mbolos disponibles")
        symbol_map[current_index] = 'SHOW_ALL'
        
        print("\n" + "=" * 70)
        
        while True:
            try:
                choice = input(f"\nüéØ Selecciona (1-{len(symbol_map)}), escribe s√≠mbolo o 'TODOS': ").strip()
                
                # Mostrar todos los s√≠mbolos
                if choice.upper() in ['TODOS', 'ALL', 'SHOW_ALL'] or (choice.isdigit() and int(choice) == len(symbol_map) and symbol_map[int(choice)] == 'SHOW_ALL'):
                    return self.show_all_symbols()
                
                # Verificar si es un s√≠mbolo directo
                if choice.upper() in [s['name'].upper() for s in symbols]:
                    selected = next(s['name'] for s in symbols if s['name'].upper() == choice.upper())
                    if self.validate_symbol(selected):
                        return selected
                    else:
                        print(f"‚ùå {selected} no est√° disponible o no se pudo activar")
                        continue
                
                # Verificar si es un n√∫mero
                if choice.isdigit():
                    idx = int(choice)
                    if idx in symbol_map and symbol_map[idx] != 'SHOW_ALL':
                        selected = symbol_map[idx]
                        if self.validate_symbol(selected):
                            return selected
                        else:
                            print(f"‚ùå {selected} no est√° disponible o no se pudo activar")
                            continue
                
                print("‚ùå Opci√≥n inv√°lida. Intenta de nuevo.")
                    
            except ValueError:
                print("‚ùå Por favor ingresa un n√∫mero v√°lido o s√≠mbolo")
            except KeyboardInterrupt:
                return None
    
    def show_all_symbols(self):
        """Mostrar todos los s√≠mbolos disponibles para encontrar COP o √≠ndices"""
        print("\nüîç BUSCANDO TODOS LOS S√çMBOLOS...")
        all_symbols = self.get_available_symbols(show_all=True)
        
        if not all_symbols:
            print("‚ùå No se encontraron s√≠mbolos")
            return None
        
        print(f"\nüìã TODOS LOS S√çMBOLOS DISPONIBLES ({len(all_symbols)}):")
        print("=" * 80)
        
        # Buscar s√≠mbolos que contengan palabras clave
        cop_symbols = [s for s in all_symbols if 'COP' in s['name'].upper()]
        index_symbols = [s for s in all_symbols if any(word in s['name'].upper() for word in ['500', 'SPX', 'DOW', 'NASDAQ', 'NDX', 'INDEX'])]
        
        if cop_symbols:
            print("\nüá®üá¥ S√çMBOLOS CON 'COP':")
            for i, symbol in enumerate(cop_symbols, 1):
                print(f"  {i}. {symbol['name']:<15} - {symbol['description']}")
        
        if index_symbols:
            print("\nüìà POSIBLES √çNDICES:")
            for i, symbol in enumerate(index_symbols, 1):
                print(f"  {i}. {symbol['name']:<15} - {symbol['description']}")
        
        # Mostrar otros s√≠mbolos en grupos
        other_symbols = [s for s in all_symbols if s not in cop_symbols and s not in index_symbols]
        
        print(f"\nüí± OTROS S√çMBOLOS DISPONIBLES:")
        print("-" * 60)
        
        for i, symbol in enumerate(other_symbols[:50], 1):  # Mostrar m√°ximo 50
            print(f"  {i:2d}. {symbol['name']:<15} - {symbol['description'][:40]}")
            if i % 20 == 0:
                cont = input("\nüìÑ Presiona Enter para ver m√°s o 'q' para seleccionar: ")
                if cont.lower() == 'q':
                    break
        
        # Permitir selecci√≥n
        while True:
            choice = input(f"\nüéØ Escribe el s√≠mbolo que quieres monitorear: ").strip()
            
            if choice.upper() in [s['name'].upper() for s in all_symbols]:
                selected = next(s['name'] for s in all_symbols if s['name'].upper() == choice.upper())
                if self.validate_symbol(selected):
                    return selected
                else:
                    print(f"‚ùå {selected} no se pudo activar")
            else:
                print("‚ùå S√≠mbolo no encontrado. Intenta de nuevo.")
                
        return None
    
    def get_historical_data(self, symbol, years=20):
        """Obtener datos hist√≥ricos con mejor manejo de timeframes"""
        print(f"\nüìä Descargando {years} a√±os de datos hist√≥ricos para {symbol}...")
        
        date_to = datetime.now()
        date_from = date_to - timedelta(days=years*365)
        
        # Intentar diferentes timeframes seg√∫n el tipo de instrumento
        timeframes = [
            (mt5.TIMEFRAME_D1, "diarios"),
            (mt5.TIMEFRAME_H4, "4 horas"),
            (mt5.TIMEFRAME_H1, "1 hora"),
            (mt5.TIMEFRAME_M30, "30 minutos")
        ]
        
        rates = None
        used_timeframe = None
        
        for timeframe, name in timeframes:
            print(f"‚è±Ô∏è  Intentando obtener datos {name}...")
            rates = mt5.copy_rates_range(symbol, timeframe, date_from, date_to)
            
            if rates is not None and len(rates) > 100:  # M√≠nimo 100 registros
                used_timeframe = name
                break
        
        if rates is None or len(rates) == 0:
            print("‚ùå No se pudieron obtener datos hist√≥ricos")
            return None
            
        print(f"‚úÖ Datos obtenidos: {len(rates)} registros ({used_timeframe})")
        
        # Convertir a DataFrame
        df = pd.DataFrame(rates)
        df['time'] = pd.to_datetime(df['time'], unit='s')
        
        # Calcular m√°ximo y m√≠nimo
        self.max_price = df['high'].max()
        self.min_price = df['low'].min()
        
        # Encontrar fechas
        max_idx = df['high'].idxmax()
        min_idx = df['low'].idxmin()
        max_date = df.loc[max_idx, 'time']
        min_date = df.loc[min_idx, 'time']
        
        # Determinar n√∫mero de decimales apropiado
        decimals = 5 if 'JPY' not in symbol else 3
        if any(idx in symbol.upper() for idx in ['US500', 'SPX500', 'SP500']):
            decimals = 2
        
        print(f"\nüìà AN√ÅLISIS HIST√ìRICO ({years} A√ëOS):")
        print("=" * 60)
        print(f"üìä S√≠mbolo: {symbol}")
        print(f"‚è±Ô∏è  Timeframe: {used_timeframe}")
        print(f"üìÖ Per√≠odo: {date_from.strftime('%Y-%m-%d')} a {date_to.strftime('%Y-%m-%d')}")
        print(f"üìà M√°ximo hist√≥rico: {self.max_price:.{decimals}f} ({max_date.strftime('%Y-%m-%d')})")
        print(f"üìâ M√≠nimo hist√≥rico: {self.min_price:.{decimals}f} ({min_date.strftime('%Y-%m-%d')})")
        print(f"üìä Rango total: {((self.max_price/self.min_price - 1) * 100):.2f}%")
        print("=" * 60)
        
        return df
    
    def monitor_price(self):
        """Monitor en tiempo real mejorado"""
        print(f"\nüíπ MONITOR EN TIEMPO REAL - {self.current_symbol}")
        print("Presiona Ctrl+C para detener\n")
        
        # Determinar decimales
        decimals = 5 if 'JPY' not in self.current_symbol else 3
        if any(idx in self.current_symbol.upper() for idx in ['US500', 'SPX500', 'SP500']):
            decimals = 2
        
        # Obtener precio inicial
        tick = mt5.symbol_info_tick(self.current_symbol)
        if tick:
            self.current_price = tick.bid if hasattr(tick, 'bid') else tick.last
            self.prev_price = self.current_price
        
        try:
            while self.running:
                tick = mt5.symbol_info_tick(self.current_symbol)
                if tick:
                    # Usar bid para forex, last para √≠ndices
                    if hasattr(tick, 'bid') and tick.bid > 0:
                        self.current_price = tick.bid
                    elif hasattr(tick, 'last') and tick.last > 0:
                        self.current_price = tick.last
                    else:
                        time.sleep(1)
                        continue
                    
                    # Determinar tendencia
                    if self.current_price > self.prev_price:
                        arrow = "üìà"
                        trend = "SUBIENDO"
                    elif self.current_price < self.prev_price:
                        arrow = "üìâ" 
                        trend = "BAJANDO"
                    else:
                        arrow = "‚û°Ô∏è"
                        trend = "LATERAL"
                    
                    # Calcular posici√≥n en rango
                    if self.max_price > self.min_price:
                        position = (self.current_price - self.min_price) / (self.max_price - self.min_price) * 100
                    else:
                        position = 50
                    
                    # Limpiar l√≠nea y mostrar
                    print(f"\rüí∞ {self.current_price:.{decimals}f} {arrow} | "
                          f"üìä {trend} | "
                          f"üìç {position:.1f}% | "
                          f"üìâ {self.min_price:.{decimals}f} | "
                          f"üìà {self.max_price:.{decimals}f} | "
                          f"üïí {datetime.now().strftime('%H:%M:%S')}    ", 
                          end='', flush=True)
                    
                    self.prev_price = self.current_price
                
                time.sleep(1)
                
        except KeyboardInterrupt:
            self.running = False
            print("\n\n‚èπ Monitor detenido")
    
    def run(self):
        """Ejecutar el monitor"""
        if not self.connect_mt5():
            return
        
        try:
            while True:
                self.current_symbol = self.select_currency()
                if not self.current_symbol:
                    break
                
                # Obtener datos hist√≥ricos
                historical = self.get_historical_data(self.current_symbol)
                if historical is None:
                    continue
                
                # Iniciar monitor
                self.running = True
                self.monitor_price()
                
                # Preguntar si continuar
                choice = input("\n‚ùì ¬øMonitorear otro instrumento? (s/n): ").lower()
                if choice != 's':
                    break
                    
        except Exception as e:
            print(f"\n‚ùå Error: {e}")
            import traceback
            traceback.print_exc()
        finally:
            mt5.shutdown()
            print("\n‚úÖ Desconectado de MT5")

def main():
    print("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
    print("‚ïë     MONITOR DE DIVISAS E √çNDICES MEJORADO        ‚ïë")
    print("‚ïë   üìà Incluye USDCOP y S&P 500 üìà                 ‚ïë")
    print("‚ïë         An√°lisis hist√≥rico de 5 a√±os            ‚ïë")
    print("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
    print()
    
    # Cargar variables de entorno
    if not load_env_file():
        return
    
    # Verificar que MT5 est√© instalado
    try:
        import MetaTrader5 as mt5
        print(f"‚úÖ MetaTrader5 versi√≥n: {mt5.__version__}")
    except ImportError:
        print("‚ùå MetaTrader5 no est√° instalado")
        print("Inst√°lalo con: pip install MetaTrader5")
        return
    
    monitor = CurrencyMonitor()
    monitor.run()

if __name__ == "__main__":
    main()